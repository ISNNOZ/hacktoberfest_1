/**
 * Copyright (C) 2023 Red Hat, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *         http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.jboss.intersmash.tools.application.openshift.helm;

import java.io.IOException;
import java.nio.file.Files;
import java.nio.file.Path;
import java.util.ArrayList;
import java.util.List;
import java.util.stream.Collectors;

import org.jboss.intersmash.model.helm.charts.values.wildfly.*;
import org.jboss.intersmash.tools.provision.helm.HelmChartOpenShiftProvisioner;

import com.fasterxml.jackson.databind.ObjectMapper;
import com.fasterxml.jackson.databind.SerializationFeature;
import com.fasterxml.jackson.dataformat.yaml.YAMLFactory;
import com.fasterxml.jackson.dataformat.yaml.YAMLGenerator;

/**
 * Defines the contract for implementing classes to represent a Helm Charts release, as seen by the provisioning
 * tooling.
 */
public class HelmChartRelease implements SerializableHelmChartRelease {

	private final HelmWildflyRelease wildflyRelease;
	private final List<Path> additionalValuesFiles = new ArrayList<>();

	public HelmChartRelease(HelmWildflyRelease wildflyRelease) {
		this(wildflyRelease, null);
	}

	public HelmChartRelease(HelmWildflyRelease wildflyRelease, List<Path> additionalValuesFiles) {
		this.wildflyRelease = wildflyRelease;
		if (additionalValuesFiles != null) {
			this.additionalValuesFiles.addAll(additionalValuesFiles.stream().collect(Collectors.toList()));
		}
	}

	/**
	 * Read the number of replicas that the release should generate
	 * The provisioner reads this values during the provisioning life cycle, e.g.: when waiting for the expected
	 * number of replicas to be ready after deploying.
	 *
	 * @return {@link Integer} representing the number of replicas that the release should generate
	 */
	public Integer getReplicas() {
		return wildflyRelease.getDeploy().getReplicas();
	}

	/**
	 * Set the number of replicas that should be generated by the release
	 * The provisioner sets this values when scaling up or down, see
	 * {@link HelmChartOpenShiftProvisioner#scale(int, boolean)}.
	 *
	 * @param replicas Number of replicas that should be generated by the release
	 */
	public void setReplicas(Integer replicas) {
		this.wildflyRelease.getDeploy().setReplicas(replicas);
	}

	/**
	 * Access the additional values files collection
	 * The provisioner will try to add a file to the helm `install/upgrade` command for each item in this list
	 *
	 * @return List of {@link Path} instances representing the location of additional values files that make the
	 * release
	 */
	public List<Path> getAdditionalValuesFiles() {
		return this.additionalValuesFiles;
	}

	@Override
	public Path toValuesFile() {
		// Handle the values file creation
		Path temp;
		try {
			temp = Files.createTempFile("values", ".yaml");
		} catch (IOException e) {
			throw new IllegalStateException("Temporary Helm Chart values file creation failed.", e);
		}
		ObjectMapper mapper = new ObjectMapper(new YAMLFactory().disable(YAMLGenerator.Feature.WRITE_DOC_START_MARKER));
		mapper.disable(SerializationFeature.WRITE_DATES_AS_TIMESTAMPS);
		try {
			mapper.writeValue(temp.toFile(), wildflyRelease);
		} catch (IOException e) {
			throw new IllegalStateException("Helm Chart values serialization failed.", e);
		}
		return temp;
	}

}
